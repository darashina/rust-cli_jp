# Rustツールのパッケージングと配布

あなたのプログラムが他の人に使ってもらえる準備ができているという自信があるなら、
それをパッケージ化してリリースする時が来たということです！

いくつかの方法がありますが、
ここでは「設定が最も早いもの」から「ユーザーにとって最も便利なもの」までの
3つを見ていきます。

## 最も早いもの：`cargo publish`

アプリを公開する最も簡単な方法はcargoを使うことです。
プロジェクトに外部の依存関係を追加した方法を覚えていますか？
Cargoはそれらをデフォルトの"クレートレジストリ"である [crates.io] からダウンロードしました。
`cargo publish` を使えば、
あなたも [crates.io] にクレートを公開できます。
そして、これはバイナリターゲットを含むすべてのクレートで動作します。

[crates.io] にクレートを公開するのはとても簡単です：
まだしていなければ、[crates.io] でアカウントを作成してください。
現在、これはGitHubであなたを認証することで行われているので、
GitHubのアカウント（そしてそこにログインしていること）が必要です。
次に、ローカルマシンでcargoを使ってログインします。
そのためには、[crates.ioのアカウントページ] に行って、
新しいトークンを作成し、
`cargo login <your-new-token>` を実行します。
これはコンピューター1台につき1回だけ行えばいいです。
これについてもっと学びたい場合は、
cargoの [パブリッシングガイド] を参照してください。

[crates.io]: https://crates.io/
[crates.ioのアカウントページ]: https://crates.io/me
[パブリッシングガイド]: https://doc.rust-lang.org/1.39.0/cargo/reference/publishing.html

今やcargoもcrates.ioもあなたのことを知ったので、
クレートを公開する準備ができました。
急いで新しいクレート（バージョン）を公開する前に、
もう一度 `Cargo.toml` を開いて、
必要なメタデータが追加されているか確認することをお勧めします。
あなたが設定可能なすべてのフィールドは、
[cargoのマニフェストフォーマット] のドキュメントに記載されています。
一般的なエントリーを簡単に紹介しましょう：

[cargoのマニフェストフォーマット]: https://doc.rust-lang.org/1.39.0/cargo/reference/manifest.html

```toml
[package]
name = "grrs"
version = "0.1.0"
authors = ["Your Name <your@email.com>"]
license = "MIT OR Apache-2.0"
description = "A tool to search files"
readme = "README.md"
homepage = "https://github.com/you/grrs"
repository = "https://github.com/you/grrs"
keywords = ["cli", "search", "demo"]
categories = ["command-line-utilities"]
```

<aside class="note">

**注：**
この例は、Rustプロジェクトで一般的な選択肢である
必須ライセンスフィールドを含んでいます：
コンパイラ自体にも同じライセンスが使われています。
また、`README.md` ファイルを参照しています。
それはあなたのプロジェクトがどのようなものかを簡単に説明するもので、
あなたのクレートのcrates.ioページだけでなく、
GitHubのリポジトリページにもデフォルトで表示されます。

</aside>

### crates.ioからバイナリをインストールする方法

crates.ioにクレートを公開する方法を見てきましたが、
どのようにインストールするか気になるかもしれません。
`cargo build` （または同様のコマンド）を実行すると、
cargoがダウンロードしてコンパイルしてくれるライブラリとは対照的に、
バイナリは明示的にインストールするように指示する必要があります。

これは `cargo install <crate-name>` で行います。
デフォルトでは、クレートをダウンロードして、
その中に含まれるすべてのバイナリターゲットを
（「リリース」モードで、だから少し時間がかかるかもしれません）
コンパイルして、`~/.cargo/bin/` ディレクトリにコピーします。
（シェルがそこにバイナリがあると知っていることを確認してください！）

gitリポジトリからクレートをインストールしたり、
クレートの特定のバイナリだけをインストールしたり、
インストール先のディレクトリを別に指定したりすることも可能です。
詳細は `cargo install --help` を見てください。

### いつ使うか

`cargo install` はバイナリクレートをインストールする簡単な方法です。
Rust開発者にとってはとても便利ですが、
大きな欠点もあります：
それは、常にソースコードを一からコンパイルするので、
あなたのツールのユーザーは、
自分のマシンにRust、cargo、そしてあなたのプロジェクトが必要とする他のすべてのシステム依存関係を
インストールする必要があるということです。
大きなRustコードベースをコンパイルするのにも時間がかかります。

これは、他のRust開発者を対象としたツールを配布するのに最適です。
例えば：
`cargo-tree` や`cargo-outdated` のような多くのcargoサブコマンドは、
これでインストールできます。

## バイナリの配布

Rustはネイティブコードにコンパイルされ、
デフォルトですべての依存関係を静的にリンクする言語です。
`grrs` という名前のバイナリを含むプロジェクトで `cargo build` を実行すると、
`grrs` という名前のバイナリファイルができあがります。
試してみてください：
`cargo build` を使うと、`target/debug/grrs` になりますし、
`cargo build --release` を実行すると、`target/release/grrs` になります。
ターゲットシステムにインストールする必要がある外部ライブラリを明示的に必要とするクレート
（システムのバージョンのOpenSSLを使うようなもの）を使わない限り、
このバイナリは一般的なシステムライブラリにだけ依存します。
つまり、
その一つのファイルを取って、
あなたと同じオペレーティングシステムを使っている人に送れば、
彼らはそれを実行できるということです。

これはもう非常に強力です！
`cargo install` の欠点のうち、2つを回避することができます：
ユーザーのマシンにRustをインストールする必要がなく、
コンパイルに1分かかる代わりに、
すぐにバイナリを実行できます。

これまで見てきたように、
`cargo build` は *すでに* バイナリをビルドしてくれています。
唯一の問題は、
それらがすべてのプラットフォームで動作することが保証されていないということです。
Windowsマシンで `cargo build` を実行した場合、
デフォルトではMacで動作するバイナリは得られません。
興味深いプラットフォームすべてに対して
これらのバイナリを自動的に生成する方法はありませんか？

### CIでバイナリリリースをビルドする

あなたのツールがオープンソースでGitHubにホストされているなら、
[Travis CI] のような無料のCI（継続的インテグレーション）サービスを設定するのはとても簡単です。
（他のプラットフォームでも動作するサービスは他にもありますが、Travisはとても人気があります。）
これは基本的に、リポジトリに変更をプッシュするたびに、
仮想マシンでセットアップコマンドを実行します。
それらのコマンドの内容や、
動作するマシンの種類は、
設定可能です。
例えば：
Rustと一般的なビルドツールがインストールされたマシンで `cargo test` を実行することは良い考えです。
これが失敗したら、
最新の変更に問題があることがわかります。

[Travis CI]: https://travis-ci.com/

これを使ってバイナリをビルドして、
GitHubにアップロードすることもできます！
確かに、`cargo build --release` を実行して、
バイナリをどこかにアップロードすれば、
準備万端のはずです。そうでしょう？
いえ、そうではありません。
私たちはまだ、ビルドしたバイナリができるだけ多くのシステムと互換性があることを確認する必要があります。
例えば、
Linuxでは現在のシステムではなく、
デフォルトのシステムライブラリに依存しない `x86_64-unknown-linux-musl` ターゲットでコンパイルできます。
macOSでは、`MACOSX_DEPLOYMENT_TARGET` を `10.7` に設定して、
10.7以前のバージョンに存在するシステム機能にだけ依存するようにできます。

この方法を使ってバイナリをビルドする例は、
LinuxとmacOS用は[こちら][wasm-pack-travis] で、
Windows用は[こちら][wasm-pack-appveyor] で（AppVeyorを使って）見ることができます。

[wasm-pack-travis]: https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91
[wasm-pack-appveyor]: https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml

もう一つの方法は、バイナリをビルドするのに必要なすべてのツールを含む
ビルド済み（Docker）イメージを使うことです。
これにより、よりエキゾチックなプラットフォームにも簡単に対応できます。
[trust] プロジェクトには、
プロジェクトに含めることができるスクリプトや、
その設定方法が含まれています。
また、AppVeyorを使ったWindowsのサポートにも対応しています。

[trust]: https://github.com/japaric/trust

ローカルでこれを設定して自分のマシンでリリースファイルを生成したいという場合でも、
trustを見てみてください。
内部的に [cross] を使っており、
cargoと同様の動作をしますが、
コマンドをDockerコンテナ内のcargoプロセスに転送します。
イメージの定義も [crossのリポジトリ][cross] で公開されています。

[cross]: https://github.com/rust-embedded/cross

### バイナリのインストール方法

ユーザーに [こちら][wasm-pack-release] のようなリリースページを紹介し、
私たちが作った成果物をダウンロードしてもらいます。
私たちが生成したリリース成果物は、特別なものではありません：
結局のところ、それらは私たちのバイナリを含むアーカイブファイルに過ぎません！
これは、あなたのツールのユーザーがそれらをブラウザでダウンロードし、
展開して（多くの場合自動的に行われます）、
好きな場所にバイナリをコピーできるということです。

[wasm-pack-release]: https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1

これにはプログラムを手動で"インストール"する経験が必要ですので、
このプログラムのインストール方法について
READMEファイルにセクションを追加したいと思うかもしれません。

<aside class="note">

**注：**
もし [trust] を使ってバイナリをビルドし、GitHubのリリースに追加した場合、
それがより簡単だと思うなら、
`curl -LSfs https://japaric.github.io/trust/install.sh | sh -s – --git your-name/repo-name` と
実行するように伝えることもできます。

</aside>

### いつ使うか

一般的に、バイナリリリースを持つのは良い考えで、
ほとんど欠点はありません。
ユーザーが手動でツールをインストールしたり更新したりする問題は解決しませんが、
Rustをインストールする必要なく最新のリリースバージョンをすぐに入手できます。

### バイナリに加えてパッケージするもの

現在、
ユーザーが私たちのリリースビルドをダウンロードすると、
バイナリファイルだけを含む `.tar.gz` ファイルが得られます。
なので、この例のプロジェクトでは、
実行可能な `grrs` という単一のファイルだけが得られます。
しかし、彼らが欲しがるかもしれないもっと他のファイルが
私たちのリポジトリにはすでにあります。
例えばこのツールの使い方を教えてくれるREADMEファイルや、
ライセンスファイルなどです。
私たちはすでにそれらを持っているので、
追加するのは簡単です。

しかし、コマンドラインツールにとって特に意味のあるもっと興味深いファイルもあります：
READMEファイルに加えて、manページも配布したり、
シェルに可能なフラグの補完を追加する設定ファイルも配布したりするのはどうでしょうか？
これらは手書きできますが、
私たちが使っている引数解析ライブラリである *clap* は、
これらのファイルをすべて生成してくれます。
詳細は[この詳細トピックの章][clap-man-pages] を参照してください。

[clap-man-pages]: ../in-depth/docs.html

## パッケージリポジトリにアプリを入れる

今まで見てきた二つの方法は、
普段マシンにソフトウェアをインストールする方法ではありません。
特にコマンドラインツールは、
ほとんどのオペレーティングシステムで
グローバルなパッケージマネージャーを使ってインストールされます。
ユーザーにとってのメリットは明らかです：
他のツールと同じ方法でインストールできるなら、
プログラムをどのようにインストールするか考える必要がありません。
これらのパッケージマネージャーは、
新しいバージョンが利用可能になったときに、
ユーザーがプログラムを更新できるようにもしてくれます。

残念ながら、異なるシステムをサポートするということは、
それらの異なるシステムがどのように動作するかを調べる必要があるということです。
中には、
リポジトリにファイルを追加するだけで簡単にできるものもあります
（例えば、macOSの `brew` 用に [このような][rg-formula] Formulaファイルを追加するなど）、
しかし他のものでは、自分でパッチを送り込んだり、
自分のツールをリポジトリに追加したりする必要があることが多いです。
[cargo-bundle](https://crates.io/crates/cargo-bundle) や
[cargo-deb](https://crates.io/crates/cargo-deb) 、
[cargo-aur](https://crates.io/crates/cargo-aur) のような便利なツールもありますが、
それらがどのように動作するかや、
それらの異なるシステム用にツールを正しくパッケージ化する方法を説明することは、
この章の範囲を超えています。

[rg-formula]: https://github.com/BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/ripgrep-bin.rb

代わりに、
Rustで書かれていて、
多くの異なるパッケージマネージャーで利用できるツールを見てみましょう。

### 例：ripgrep

[ripgrep] は `grep/ack/ag` の代替品で、Rustで書かれています。
とても成功しており、多くのオペレーティングシステムでパッケージ化されています：
READMEの ["Installation"セクション][rg-install] を見てください！

それは、あなたがそれをインストールすることができる
いくつかの異なる方法をリストしていることに注意してください：
それはバイナリを含むGitHubリリースへのリンクから始まり、
あなたはそれらを直接ダウンロードできます。
そして、それはさまざまなパッケージマネージャーを使ってそれをインストールする方法をリストします。
最後に、`cargo install` を使ってインストールすることもできます。

これはとても良い考えのようです：
ここで提示された方法の中から一つを選んだり選ばなかったりするのではなく、
`cargo install` から始めて、
バイナリリリースを追加して、
最終的にはシステムのパッケージマネージャーを使ってツールを配布するようにしましょう。

[ripgrep]: https://github.com/BurntSushi/ripgrep
[rg-install]: https://github.com/BurntSushi/ripgrep/tree/31adff6f3c4bfefc9e77df40871f2989443e6827#installation
