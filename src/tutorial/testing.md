# テスト

何十年にもわたるソフトウェア開発で、
人々はひとつの真実を発見しました：
"テストされていないソフトウェアが機能することはめったにない"。
（多くの人はこう言うでしょう：
"ほとんどのテスト済みソフトウェアも機能しない"。
しかし、私たちは皆、楽観主義者でしょ？）
だから、あなたのプログラムがあなたの期待通りに動くことを確認するためには、
それをテストするのが賢明です。

そのための簡単な方法の一つは、
あなたのプログラムがどの様に動作するのかを記述した
`README` ファイルを書くことです。
そして、新しいリリースを作る準備ができたら、
`README` に目を通し、
その動作が期待通りであることを確認しましょう。
誤った入力に対してプログラムがどのように反応するかも書いておくことで、
これをより厳密な確認にすることもできます。

もうひとつ、妙案があります：
コードを書く前に `README` を書きましょう。

<aside>

**注：**
[テスト駆動開発]（TDD）をご存じない方はご覧ください。

[テスト駆動開発]: https://en.wikipedia.org/wiki/Test-driven_development

</aside>

## 自動テスト

しかし、これをすべて手作業でやるのは大変です。
これにはかなりの時間がかかりますし、
同時に、
多くの人はコンピューターに指示を出すことを楽しむようになっています。
これらのテストを自動化する方法について話しましょう。

Rustにはテスト・フレームワークが組み込まれているので、
まず最初のテストを書いてみましょう：

```rust,ignore
# fn answer() -> i32 {
#   42
# }
#
#[test]
fn check_answer_validity() {
    assert_eq!(answer(), 42);
}
```

このコードのスニペットをほとんどすべてのファイルに記述することができ、
`cargo test` はそれを見つけて実行します。
ここで重要なのは、`#[test]`  属性です。
これにより、ビルドシステムがこのような関数を検出してテストとして実行し、
パニックを起こさないことを確認します。

<aside class="exercise">

**練習問題：**
このテストを成功させてください。

以下のような出力になるはずです：

```text
running 1 test
test check_answer_validity ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

</aside>

さて、テストの書き方について見てきましたが、
今度は何をテストするのかを考えましょう。
これまで見てきたように、関数に対するアサーションを書くのはとても簡単です。
しかし、CLI アプリケーションは複数の関数から構成されることがよくあります！
さらに悪いことに、ユーザーの入力を処理したり、
ファイルを読み込んだり、
出力を書き込んだりすることもよくあります。

## コードをテスト可能にする

機能性のテストには、2つの相補的なアプローチがあります：
アプリケーション全体を構築するための、個々の小さな機能をテストすることは、
「ユニットテスト」と呼ばれます。
また、「ブラックボックステスト」や「統合テスト」と呼ばれる、
最終的なアプリケーションを「外から」テストする方法もあります。
まず、1つ目から始めましょう。

何をテストすべきかを考えるために、
プログラムの特徴を見てみましょう。
主に、`grrs` は与えられたパターンにマッチする行をプリントアウトすることになっています。
そこで、*まさにこのための* ユニットテストを書いてみましょう：
ロジックの最も重要な部分が確実に機能するようにしたいですし、
（例えばCLIの引数を扱うような）
セットアップ・コードに依存しない方法でそれを実現したいです。

`grrs` の [最初の実装](impl-draft.md) に戻ります、
私たちは `main` 関数に次のコードブロックを書きました：

```rust,ignore
// ...
for line in content.lines() {
    if line.contains(&args.pattern) {
        println!("{}", line);
    }
}
```

悲しいことに、これをテストするのはあまり簡単ではありません。
まず、メイン関数の中にあるので、簡単に呼び出すことができません。
これは、このコードを関数に移すことで簡単に解決できます：

```rust,no_run
fn find_matches(content: &str, pattern: &str) {
    for line in content.lines() {
        if line.contains(pattern) {
            println!("{}", line);
        }
    }
}
```

では、この関数をテストで呼び出し、
その出力を見てみましょう：

```rust,ignore
#[test]
fn find_a_match() {
    find_matches("lorem ipsum\ndolor sit amet", "lorem");
    assert_eq!( // uhhhh
```

それとも...できるかな？
今のところ、`find_matches` は `stdout` 、つまりターミナルに直接プリントします。
テストではこれを簡単にキャプチャすることはできません！
これは、実装後にテストを書くときによく出てくる問題です：
私たちは、それが使用されるコンテクストにしっかりと組み込まれた関数を書きました。

<aside class="note">

**注：**
これは小さなCLIアプリケーションを書く場合には全く問題ありません。
すべてをテスト可能にする必要はありません！
しかし、コードのどの部分にユニットテストを書きたいかを考えることは重要です。
この関数をテスト可能なものに変更するのは簡単ですが、
常にそうであるとは限りません。

</aside>

さて、どうすればテスト可能になるでしょうか？
どうにかして出力をキャプチャする必要があります。
Rustの標準ライブラリには、
I/O（入出力）を扱うための優れた抽象化機能がいくつかありますが、
ここでは [`std::io::Write`] と呼ばれるものを利用しましょう。
これは、文字列や `stdout` など、
書き込み可能なものを抽象化する [トレイト][trpl-traits] です。

[trpl-traits]: https://doc.rust-lang.org/book/ch10-02-traits.html
[`std::io::Write`]: https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html

Rustを学習する中で "トレイト" という言葉を耳にするのが初めてだとしたら、
それは素晴らしいことです。
トレイトはRustの最も強力な機能の1つです。
Javaでいうところのインターフェイス、
Haskell（あなたがより親しんでいる言語であれば何でもいいです）
でいうところの型クラスのようなものだと思ってもらえばいいです。
トレイトは異なる型で共有できる振る舞いを抽象化することができます。
だから、トレイトを使用するコードは、
非常に汎用的で柔軟な方法でアイデアを表現することができます。
つまり、読むのが難しくなるということですが、
それに怯える必要はありません：
Rustを何年も使っている人でも、
その汎用コードが何をするのかすぐに理解できるとは限りません。
その場合、具体的な使い方を考えることが助けになります。
例えば、
私たちの場合、
抽象化する動作は「それに書き込む」になります。
これを実装（"impl"）した型の例としては、
以下のようなものがあります：
端末の標準出力、ファイル、メモリ上のバッファ、TCPネットワーク接続。
( [std::io::Writeのドキュメント][`std::io::Write`] を下にスクロールすると、
"インプリメンター"のリストを見ることができます。)

この知識をもとに、
3番目のパラメータを受け取るように関数を変更してみましょう。
このパラメータは、`Write` を実装する型であれば何でもかまいません。
こうすれば、
テストに単純な文字列を与えて、
それに対してアサーションを行うことができます。
このバージョンの `find_matches` は、以下のようになります：

```rust,ignore
{{#include testing/src/main.rs:23:29}}
```

新しいパラメータは `mut writer` 、
つまり私たちが "ライター "と呼ぶミュータブルなものです。
その型は `impl std::io::Write` で、
「 `Write トレイト` を実装するあらゆる型のプレースホルダー」
と読むことができます。
また、先ほど使った `println!(…)` を `writeln!(writer, …)` に
置き換えたことにも注目してください。
`println!` は `writeln!` と同じ働きをしますが、
常に標準出力を使います。

これで出力をテストできます：

```rust,ignore
{{#include testing/src/main.rs:31:36}}
```

アプリケーション・コードでこれを使うには、
`main` の `find_matches` の呼び出しに、
3番目のパラメータとして [`&mut std::io::stdout()`][stdout] を追加する必要があります。
以下は、前の章で見てきたことをベースに、
抽出した `find_matches` 関数を使用したメイン関数の例になります：

```rust,ignore
{{#include testing/src/main.rs:13:21}}
```

[stdout]: https://doc.rust-lang.org/1.39.0/std/io/fn.stdout.html

<aside class="note">

**注：**
`stdout` は（文字列ではなく）バイトを想定しているので、
`std::fmt::Write` の代わりに`std::io::Write` を使います。
その結果、
テストでは "ライター "として空のベクトルを与えており
（その型は `Vec<u8>` と推論されます。）、
`assert_eq!` では、`b"foo"` を使っています。
（プレフィックスの `b` は、これを *バイト文字列リテラル* にするので、
その型は `&str` ではなく`&[u8]` になります。）

</aside>

<aside class="note">

**注：**
この関数を `String` を返すようにすることもできますが、
そうすると動作が変わってしまいます。
ターミナルに直接書き込む代わりに、
すべてを文字列にして集め、
最後にすべての結果をまとめてダンプする事になります。

</aside>

<aside class="exercise">

**練習問題：**
[`writeln!`] は [`io::Result`] を返します。
バッファが一杯で展開できない場合など、書き込みに失敗することがあるからです。
`find_matches` にエラー処理を追加してください。

[`writeln!`]: https://doc.rust-lang.org/1.39.0/std/macro.writeln.html
[`io::Result`]: https://doc.rust-lang.org/1.39.0/std/io/type.Result.html

</aside>

私たちは、このコードを簡単にテスト可能にする方法を見てきました。
私たちは

1. 私たちのアプリケーションの核となる部分を特定し、
2. そのコードを関数の中に移し、
3. そして、よりフレキシブルにしました。

目標はテスト可能なものにすることだったにもかかわらず、
最終的に出来上がったのは、
非常にイディオム的で再利用可能なRustコードでした。
すごいことです！

## コードをライブラリとバイナリ・ターゲットに分割する

ここでもうひとつ出来ることがあります。
ここまでで、書いたものはすべて `src/main.rs` ファイルに入れました。
つまり、現在のプロジェクトは単一のバイナリを生成するということです。
しかし、次のようにコードをライブラリとして公開することもできます：

1. `find_matches` 関数を新規の `src/lib.rs` に記述します。
2. `fn` の前に `pub` を追加して（ `pub fn find_matches` となります）、
   ライブラリのユーザーがアクセスできるようにします。
3. `src/main.rs` から `find_matches` を削除します。
4. `fn main` の中で、`find_matches` の呼び出しの前に `grrs::` を付けて、
   `grrs::find_matches(...)` とします。
   つまり、先ほど書いたライブラリの関数を使うということです！

Rustのプロジェクトの扱い方はかなり柔軟なので、
早い段階でクレートのライブラリ部分に何を入れるか考えておくといいでしょう。
例えば、アプリケーション固有のロジック用のライブラリを最初に書き、
それを他のライブラリと同じようにCLIで使うことを考えることができます。
あるいは、プロジェクトに複数のバイナリがある場合は、
共通機能をそのクレートのライブラリ部分に入れることも出来ます。

<aside class="note">

**注：**
すべてを `src/main.rs` にまとめるといえば：
このままでは読みづらくなってしまいます。
[モジュール・システム] は、コードの構造化と整理に役立ちます。

[モジュール・システム]: https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html

</aside>


## CLIアプリケーションの実行テスト

これまで、アプリケーションの *ビジネス・ロジック* をテストするために、
わざわざ `find_matches` 関数をテストしてきました。
これは非常に貴重であり、
十分にテストされたコードベースへの素晴らしい第一歩です。
（通常、この種のテストは「ユニットテスト」と呼ばれます。）

しかし、テストしていないコードもたくさんあります：
外部とやりとりするために書いたすべてのコードです！
`main` 関数を書きましたが、
ユーザーが指定したパスの引数を使わず、
誤ってハードコーディングされた文字列を残してしまったとしましょう。
そのためのテストも書くべきです！
（このレベルのテストは、
しばしば「統合テスト」あるいは「システムテスト」と呼ばれます。）

基本的には、
私たちはまだ関数を書いて、
`#[test]` というアノテーションを付けています。
問題は、これらの関数の中で何をするかということです。
例えば、プロジェクトのメイン・バイナリを使って、
普通のプログラムのように実行したいでしょう。
また、これらのテストを新しいディレクトリの新しいファイル：`tests/cli.rs` に入れるでしょう。

<aside>

**注：**
慣習上、
`cargo` は `tests/` ディレクトリにある統合テストを探します。
同様に、
ベンチマークを `benches/` に、
例を `examples/` に探します。
これらの慣習はメインのソースコードにも適用されます：
ライブラリは `src/lib.rs` ファイルを持ち、
メインバイナリは `src/main.rs` にあります。
また、複数のバイナリがある場合、
`cargo` はそれらが `src/bin/<name>.rs` にあると期待します。
これらの慣習に従うことで、
Rustのコードを読み慣れた人があなたのコードベースをより発見しやすくなります。

</aside>

思い起こせば、
`grrs` はファイル内の文字列を検索する小さなツールです。
マッチする文字列が見つかることは以前にテストしました。
他にどんな機能をテストできるか考えてみましょう。

私が考え出したものは、この様なものです。

- ファイルが存在しないときに何が起こりますか？
- マッチするものがないときに出力はどうなりますか？
- 引数の一つ（または両方）を忘れたときに、エラーで終了しますか？

これらはすべて有効なテストケースです。
さらに、
"ハッピーパス"のための一つのテストケースも含めるべきです。
つまり、少なくとも一つのマッチを見つけて、
それを出力するということです。

このようなテストを簡単にするために、
[`assert_cmd`] クレートを使ってみましょう。
メインのバイナリを実行して、
その挙動を確認することができる、
便利なヘルパーがたくさんあります。
さらに、
[`predicates`] クレートも追加します。
それは `assert_cmd` がテストできる
（そして素晴らしいエラーメッセージを持つ）
アサーションを書くのに役立ちます。
これらの依存関係をメインリストではなく、
`Cargo.toml` の"dev dependencies"セクションに追加します。
それらはクレートを使うときではなく、
開発するときにだけ必要です。

```toml
{{#include testing/Cargo.toml:16:18}}
```

[`assert_cmd`]: https://docs.rs/assert_cmd
[`predicates`]: https://docs.rs/predicates

セットアップが大変そうです。
それでも、
さっそく `tests/cli.rs` ファイルを作ってみましょう：

```rust,ignore
{{#include testing/tests/cli.rs:1:15}}
```

このテストは、上で書いたテストと同じように、
`cargo test` で実行できます。
`Command::cargo_bin(“grrs”)` がメインバイナリをコンパイルする必要があるため、
最初の一回は少し時間がかかるかもしれません。

## テストファイルの生成

今見てきたテストは、入力ファイルが存在しないときに、
プログラムがエラーメッセージを出力するかどうかだけをチェックしています。
それは重要なテストですが、
最も重要なものではないかもしれません：
今度は、ファイルの中で見つけたマッチを実際に出力するかどうかをテストしてみましょう！

内容が分かっているファイルが必要です。
そうすれば、プログラムが *何を返すべきか* を知ることができ、
コードの中でこの期待値をチェックできます。
一つのアイデアとして、カスタムコンテンツを持つファイルをプロジェクトに追加して、
それをテストに使うという方法があります。
もう一つは、テストの中で一時ファイルを作るという方法です。
このチュートリアルでは、
後者の方法を見ていきます。
主に、より柔軟性があり、他の場合にも使えるからです；
例えば、ファイルを変更するプログラムをテストするときなどです。

これらの一時ファイルを作るために、
[`assert_fs`] というクレートを使います。
`Cargo.toml` の `dev-dependencies` に追加しましょう：

```toml
{{#include testing/Cargo.toml:19}}
```

[`assert_fs`]: https://docs.rs/assert_fs

ここに新しいテストケース
（他のテストケースの下に書くことができます）を書くと、
まずテンポラリファイル
（パスを取得できるように"名前付き"のもの）を作成し、
そこにテキストを書き込んでから、
プログラムを実行して正しい出力が得られるかどうかを確認します。
`ファイル` がスコープから外れると
（関数の最後で）、
実際の一時ファイルは自動的に削除されます。

```rust,ignore
{{#include testing/tests/cli.rs:17:32}}
```

<aside class="exercise">

**練習問題：**
パターンとして空文字列を渡すための統合テストを追加してください。
必要に応じてプログラムを調整してください。

</aside>

## 何をテストすべきか？

統合テストを書くのは確かに楽しいことですが、
それには時間がかかりますし、
アプリケーションの振る舞いが変わったときに更新する必要もあります。
時間を賢く使うために、
何をテストすべきか自問自答してみるべきです。

一般的には、ユーザーが観察できるすべてのタイプの動作について
統合テストを書くのがよいでしょう。
つまり、すべてのエッジケースをカバーする必要はありません：
通常は、さまざまなタイプの例を用意して、
エッジケースはユニットテストに任せるだけで十分です。

また、自分で積極的に制御できないことにテストの焦点を当てないのも良い考えです。
`–help` の正確なレイアウトをテストするのは得策ではありません。
なぜなら、それはあなたのために生成されるものだからです。
代わりに、特定の要素が存在するかどうかをチェックするだけでよいでしょう。

プログラムの性質によっては、
他のテスト技法も試してみることができます。
例えば、
プログラムの一部を抽出して、
エッジケースを考え出そうとしながらユニットテストとして多くの例を書いている場合は、
[`proptest`] を調べてみるべきです。
任意のファイルを消費して解析するプログラムがある場合は、
エッジケースでバグを見つけるために [fuzzer] を書いてみるとよいでしょう。

[`proptest`]: https://docs.rs/proptest
[fuzzer]: https://rust-fuzz.github.io/book/introduction.html

<aside>

**注：**
この章で使った完全で実行可能なソースコードは、
[本書のリポジトリ][src] にあります。

[src]: https://github.com/darashina/rust-cli_jp/tree/main/src/tutorial/testing

</aside>
